{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":["class-call-check"]},"ignored":false,"code":"/* global LocalCollection */\n/* global Factory:true */\n\nvar factories = {};\n\nFactory = (function () {\n  function Factory(name, collection, attributes) {\n    babelHelpers.classCallCheck(this, Factory);\n\n    this.name = name;\n    this.collection = collection;\n    this.attributes = attributes;\n    this.afterHooks = [];\n    this.sequence = 0;\n  }\n\n  Factory.prototype.after = (function () {\n    function after(fn) {\n      this.afterHooks.push(fn);\n      return this;\n    }\n\n    return after;\n  })();\n\n  return Factory;\n})();\n\nFactory.define = function (name, collection, attributes) {\n  factories[name] = new Factory(name, collection, attributes);\n  return factories[name];\n};\n\nFactory.get = function (name) {\n  var factory = factories[name];\n  if (!factory) {\n    throw new Error(\"Factory: There is no factory named \" + name);\n  }\n  return factory;\n};\n\nFactory.build = function (name) {\n  var attributes = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  var factory = Factory.get(name);\n  var result = {};\n\n  // \"raw\" attributes without functions evaluated, or dotted properties resolved\n  var extendedAttributes = _.extend({}, factory.attributes, attributes);\n\n  // either create a new factory and return its _id\n  // or return a 'fake' _id (since we're not inserting anything)\n  var makeRelation = function (relName) {\n    if (options.insert) {\n      return Factory.create(relName)._id;\n    }\n    if (options.tree) {\n      return Factory.build(relName, {}, { tree: true });\n    }\n    // fake an id on build\n    return Random.id();\n  };\n\n  var getValue = function (value) {\n    return value instanceof Factory ? makeRelation(value.name) : value;\n  };\n\n  var getValueFromFunction = function (func) {\n    var api = {\n      sequence: function (fn) {\n        return fn(factory.sequence);\n      }\n    };\n    var fnRes = func.call(result, api);\n    return getValue(fnRes);\n  };\n\n  factory.sequence += 1;\n\n  var walk = function (record, object) {\n    _.each(object, function (value, key) {\n      var newValue = value;\n      // is this a Factory instance?\n      if (value instanceof Factory) {\n        newValue = makeRelation(value.name);\n      } else if (_.isArray(value)) {\n        newValue = value.map(function (element) {\n          if (_.isFunction(element)) {\n            return getValueFromFunction(element);\n          }\n          return getValue(element);\n        });\n      } else if (_.isFunction(value)) {\n        newValue = getValueFromFunction(value);\n        // if an object literal is passed in, traverse deeper into it\n      } else if (Object.prototype.toString.call(value) === '[object Object]') {\n          record[key] = record[key] || {};\n          return walk(record[key], value);\n        }\n\n      var modifier = { $set: {} };\n\n      if (key !== '_id') {\n        modifier.$set[key] = newValue;\n      }\n\n      LocalCollection._modify(record, modifier);\n    });\n  };\n\n  walk(result, extendedAttributes);\n\n  if (!options.tree) {\n    result._id = extendedAttributes._id || Random.id();\n  }\n  return result;\n};\n\nFactory.tree = function (name, attributes) {\n  return Factory.build(name, attributes, { tree: true });\n};\n\nFactory._create = function (name, doc) {\n  var collection = Factory.get(name).collection;\n  var insertId = collection.insert(doc);\n  var record = collection.findOne(insertId);\n  return record;\n};\n\nFactory.create = function (name) {\n  var attributes = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  var doc = Factory.build(name, attributes, { insert: true });\n  var record = Factory._create(name, doc);\n\n  Factory.get(name).afterHooks.forEach(function (cb) {\n    return cb(record);\n  });\n\n  return record;\n};\n\nFactory.extend = function (name) {\n  var attributes = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  return _.extend(_.clone(Factory.get(name).attributes), attributes);\n};","ast":null,"map":{"version":3,"sources":["/factory.js"],"names":[],"mappings":"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","file":"/factory.js.map","sourcesContent":["/* global LocalCollection */\n/* global Factory:true */\n\nconst factories = {};\n\nFactory = class Factory {\n  constructor(name, collection, attributes) {\n    this.name = name;\n    this.collection = collection;\n    this.attributes = attributes;\n    this.afterHooks = [];\n    this.sequence = 0;\n  }\n\n  after(fn) {\n    this.afterHooks.push(fn);\n    return this;\n  }\n};\n\nFactory.define = (name, collection, attributes) => {\n  factories[name] = new Factory(name, collection, attributes);\n  return factories[name];\n};\n\nFactory.get = name => {\n  const factory = factories[name];\n  if (! factory) {\n    throw new Error(\"Factory: There is no factory named \" + name);\n  }\n  return factory;\n};\n\nFactory.build = (name, attributes = {}, options = {}) => {\n  const factory = Factory.get(name);\n  const result = {};\n\n  // \"raw\" attributes without functions evaluated, or dotted properties resolved\n  const extendedAttributes = _.extend({}, factory.attributes, attributes);\n\n  // either create a new factory and return its _id\n  // or return a 'fake' _id (since we're not inserting anything)\n  const makeRelation = relName => {\n    if (options.insert) {\n      return Factory.create(relName)._id;\n    }\n    if (options.tree) {\n      return Factory.build(relName, {}, {tree: true});\n    }\n    // fake an id on build\n    return Random.id();\n  };\n\n  const getValue = value => {\n    return (value instanceof Factory) ? makeRelation(value.name) : value;\n  };\n\n  const getValueFromFunction = func => {\n    const api = {\n      sequence: fn => fn(factory.sequence)\n    };\n    const fnRes = func.call(result, api);\n    return getValue(fnRes);\n  };\n\n  factory.sequence += 1;\n\n  const walk = (record, object) => {\n    _.each(object, (value, key) => {\n      let newValue = value;\n      // is this a Factory instance?\n      if (value instanceof Factory) {\n        newValue = makeRelation(value.name);\n      } else if (_.isArray(value)) {\n        newValue = value.map(element => {\n          if (_.isFunction(element)) {\n            return getValueFromFunction(element);\n          }\n          return getValue(element);\n        });\n      } else if (_.isFunction(value)) {\n        newValue = getValueFromFunction(value);\n      // if an object literal is passed in, traverse deeper into it\n      } else if (Object.prototype.toString.call(value) === '[object Object]') {\n        record[key] = record[key] || {};\n        return walk(record[key], value);\n      }\n\n      const modifier = {$set: {}};\n\n      if (key !== '_id') {\n        modifier.$set[key] = newValue;\n      }\n\n      LocalCollection._modify(record, modifier);\n    });\n  };\n\n  walk(result, extendedAttributes);\n\n  if (! options.tree) {\n    result._id = extendedAttributes._id || Random.id();\n  }\n  return result;\n};\n\nFactory.tree = (name, attributes) => {\n  return Factory.build(name, attributes, {tree: true});\n};\n\nFactory._create = (name, doc) => {\n  const collection = Factory.get(name).collection;\n  const insertId = collection.insert(doc);\n  const record = collection.findOne(insertId);\n  return record;\n};\n\nFactory.create = (name, attributes = {}) => {\n  const doc = Factory.build(name, attributes, {insert: true});\n  const record = Factory._create(name, doc);\n\n  Factory.get(name).afterHooks.forEach(cb => cb(record));\n\n  return record;\n};\n\nFactory.extend = (name, attributes = {}) => {\n  return _.extend(_.clone(Factory.get(name).attributes), attributes);\n};\n"]},"hash":"122219ebfb57e81083d69a15679f16bb621b08e6"}
