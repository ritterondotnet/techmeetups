{"version":3,"sources":["matb33:collection-hooks/collection-hooks.js","matb33:collection-hooks/insert.js","matb33:collection-hooks/update.js","matb33:collection-hooks/remove.js","matb33:collection-hooks/upsert.js","matb33:collection-hooks/find.js","matb33:collection-hooks/findone.js","matb33:collection-hooks/users-compat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,4B;AACA,kD;AACA,mE;AACA,yB;;AAEA,iB;AACA,8E;AACA,wE;;AAEA,mB;AACA,a;AACA,8F;AACA,iF;AACA,8E;AACA,I;AACA,8C;AACA,qC;AACA,gD;AACA,I;AACA,qC;AACA,iD;AACA,G;AACA,E;;AAEA,kD;AACA,a;;AAEA,wB;AACA,qC;AACA,gD;AACA,O;AACA,G;;AAEA,wB;AACA,S;AACA,uD;AACA,mD;AACA,gD;AACA,kB;;AAEA,kB;AACA,wD;AACA,mC;AACA,K;AACA,G;;AAEA,gB;AACA,E;;AAEA,iG;AACA,2D;AACA,6C;AACA,mD;AACA,+C;AACA,8D;;AAEA,6C;AACA,mD;;AAEA,+C;AACA,2D;AACA,4D;AACA,yB;AACA,yE;AACA,W;;AAEA,gB;AACA,+C;AACA,oE;AACA,6B;AACA,6E;AACA,e;AACA,Y;AACA,+B;AACA,mE;AACA,W;AACA,U;AACA,Q;AACA,O;AACA,K;;AAEA,mE;AACA,kC;AACA,2E;AACA,2D;;AAEA,iE;AACA,6C;AACA,sF;;AAEA,uD;AACA,oC;;AAEA,2C;AACA,uC;AACA,2B;AACA,mD;AACA,+D;AACA,S;AACA,M;;AAEA,sC;AACA,qD;AACA,mD;AACA,O;;AAEA,6E;AACA,+E;AACA,yE;AACA,4E;AACA,8E;AACA,sF;AACA,6B;AACA,sD;AACA,U;;AAEA,8B;AACA,oC;AACA,e;AACA,a;AACA,+B;AACA,iD;AACA,iD;AACA,gD;AACA,4C;AACA,wB;AACA,+C;AACA,sE;AACA,sD;AACA,U;AACA,6B;AACA,a;AACA,Q;AACA,M;AACA,K;AACA,E;;AAEA,sE;AACA,2B;AACA,E;;AAEA,wD;AACA,yB;AACA,E;;AAEA,+E;AACA,4F;AACA,E;;AAEA,2F;AACA,oD;AACA,oD;AACA,kD;AACA,wD;AACA,iB;AACA,E;;AAEA,2E;AACA,kB;;AAEA,gF;;AAEA,I;AACA,qC;AACA,yC;AACA,4B;AACA,wD;AACA,wC;AACA,O;AACA,G;AACA,I;;AAEA,8E;AACA,gD;AACA,gB;AACA,4E;AACA,wE;AACA,6E;AACA,uC;AACA,yB;AACA,4B;AACA,K;AACA,G;;AAEA,6D;AACA,6B;AACA,gD;AACA,E;;AAEA,qE;AACA,kD;AACA,6E;AACA,0B;AACA,yD;AACA,4B;AACA,kB;;AAEA,yC;AACA,4C;AACA,2H;AACA,4C;AACA,+C;AACA,6D;AACA,yB;AACA,sC;AACA,yD;;AAEA,mD;AACA,uC;AACA,6B;AACA,S;AACA,4C;AACA,Y;AACA,sB;AACA,K;AACA,4C;AACA,K;;AAEA,gB;AACA,E;;AAEA,kF;AACA,sE;;AAEA,4F;;AAEA,yC;AACA,yE;AACA,0B;AACA,sD;AACA,kC;AACA,0C;AACA,G;AACA,E;;AAEA,kE;AACA,4E;AACA,kF;;AAEA,8C;AACA,sC;;AAEA,+B;AACA,iD;AACA,gE;AACA,e;AACA,I;;AAEA,kC;AACA,sD;;AAEA,iC;AACA,2C;AACA,8C;AACA,K;AACA,G;AACA,E;;AAEA,mC;AACA,gD;AACA,+C;AACA,Q;AACA,iD;AACA,C;;AAEA,sB;AACA,gC;AACA,0C;AACA,kD;AACA,2D;AACA,uC;AACA,qE;AACA,qC;AACA,S;AACA,O;AACA,I;;AAEA,4E;AACA,+D;AACA,gE;AACA,6C;AACA,I;AACA,C;;;;;;;;;;;;;;;;;;;AC1RA,0H;AACA,kB;AACA,wD;AACA,8B;AACA,qC;AACA,iB;;AAEA,kB;AACA,uB;;AAEA,W;AACA,yB;AACA,S;AACA,2C;AACA,kG;AACA,sC;AACA,S;;AAEA,8B;AACA,iB;AACA,+C;AACA,c;AACA,K;AACA,G;;AAEA,2B;AACA,sB;AACA,a;AACA,iC;AACA,mB;AACA,K;AACA,2B;AACA,kF;AACA,0C;AACA,yC;AACA,S;AACA,K;AACA,c;AACA,G;;AAEA,c;AACA,iD;AACA,qD;AACA,6C;AACA,M;AACA,oC;AACA,U;AACA,mC;AACA,qD;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AClDA,0H;AACA,kB;AACA,wD;AACA,8B;AACA,qC;AACA,6C;AACA,wE;;AAEA,uB;AACA,sB;AACA,iC;AACA,uB;;AAEA,8B;AACA,uB;AACA,iB;AACA,G;;AAEA,yB;AACA,S;AACA,4C;AACA,oD;AACA,wF;AACA,iE;AACA,O;;AAEA,gE;AACA,0B;AACA,4C;AACA,4C;AACA,gG;AACA,iH;AACA,yB;AACA,uC;AACA,kD;AACA,a;AACA,S;AACA,O;;AAEA,e;AACA,2C;AACA,qC;AACA,sH;AACA,wC;AACA,W;AACA,S;;AAEA,8B;AACA,iB;AACA,+C;AACA,c;AACA,K;AACA,G;;AAEA,iC;AACA,2B;AACA,sD;AACA,uG;;AAEA,0C;AACA,qC;AACA,kC;AACA,yC;AACA,sD;AACA,+B;AACA,oB;AACA,oE;AACA,W;AACA,S;AACA,K;AACA,G;;AAEA,c;AACA,sD;AACA,2B;AACA,6C;AACA,M;AACA,oC;AACA,U;AACA,4C;AACA,oB;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;ACnFA,0H;AACA,kB;AACA,wD;AACA,8B;AACA,qC;AACA,6B;AACA,wE;;AAEA,uB;AACA,uB;;AAEA,yB;AACA,S;AACA,4C;AACA,+E;AACA,O;;AAEA,gE;AACA,0B;AACA,qC;AACA,sC;AACA,W;AACA,O;;AAEA,e;AACA,2C;AACA,qC;AACA,4F;AACA,wC;AACA,W;AACA,S;;AAEA,8B;AACA,iB;AACA,+C;AACA,c;AACA,K;AACA,G;;AAEA,uB;AACA,2B;AACA,0C;AACA,qC;AACA,8F;AACA,W;AACA,S;AACA,K;AACA,G;;AAEA,c;AACA,4C;AACA,iB;AACA,6C;AACA,M;AACA,oC;AACA,U;AACA,0C;AACA,Y;AACA,kB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AC5DA,8H;AACA,kB;AACA,wD;AACA,8B;AACA,qC;AACA,6C;AACA,wE;;AAEA,uB;AACA,sB;AACA,iC;AACA,uB;;AAEA,8B;AACA,uB;AACA,iB;AACA,G;;AAEA,yB;AACA,oC;AACA,kD;AACA,sF;AACA,+D;AACA,K;;AAEA,8D;AACA,mC;AACA,yG;AACA,+G;AACA,4C;AACA,4C;AACA,uB;AACA,qC;AACA,gD;AACA,W;AACA,O;AACA,K;;AAEA,a;AACA,2B;AACA,sD;AACA,sE;AACA,sC;AACA,S;;AAEA,8B;AACA,K;AACA,G;;AAEA,uC;AACA,2B;AACA,sD;AACA,uG;;AAEA,qD;AACA,qC;AACA,kC;AACA,yC;AACA,sD;AACA,+B;AACA,oB;AACA,oE;AACA,W;AACA,S;AACA,K;AACA,G;;AAEA,iC;AACA,8D;AACA,a;AACA,6B;AACA,mB;AACA,K;AACA,2B;AACA,kF;AACA,qD;AACA,yC;AACA,S;AACA,K;AACA,G;;AAEA,c;AACA,iD;AACA,2B;AACA,yC;AACA,c;AACA,6C;AACA,O;;AAEA,mD;AACA,6C;AACA,S;AACA,M;;AAEA,iD;AACA,sC;AACA,O;AACA,U;AACA,oD;AACA,sC;AACA,O;;AAEA,yB;AACA,kC;AACA,Y;AACA,sC;AACA,K;;AAEA,e;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AC9GA,wH;AACA,kB;AACA,wD;AACA,iB;;AAEA,uB;AACA,sB;;AAEA,W;AACA,yB;AACA,yC;AACA,2D;AACA,oC;AACA,O;;AAEA,4B;AACA,G;;AAEA,0B;AACA,2B;AACA,0C;AACA,6D;AACA,S;AACA,K;AACA,G;;AAEA,iC;AACA,a;;AAEA,a;AACA,G;;;;;;;;;;;;;;;;;;AC9BA,2H;AACA,kB;AACA,wD;AACA,iB;;AAEA,uB;AACA,sB;;AAEA,W;AACA,yB;AACA,yC;AACA,2D;AACA,oC;AACA,O;;AAEA,4B;AACA,G;;AAEA,uB;AACA,2B;AACA,0C;AACA,0D;AACA,S;AACA,K;AACA,G;;AAEA,iC;AACA,a;;AAEA,a;AACA,G;;;;;;;;;;;;;;;;;;AC9BA,mB;AACA,+E;AACA,kD;;AAEA,oC;AACA,kI;AACA,qE;AACA,C","file":"/packages/matb33_collection-hooks.js","sourcesContent":["// Relevant AOP terminology:\n// Aspect: User code that runs before/after (hook)\n// Advice: Wrapper code that knows when to call user code (aspects)\n// Pointcut: before/after\n\nvar advices = {};\nvar Tracker = Package.tracker && Package.tracker.Tracker || Package.deps.Deps;\nvar publishUserId = Meteor.isServer && new Meteor.EnvironmentVariable();\n\nCollectionHooks = {\n  defaults: {\n    before: { insert: {}, update: {}, remove: {}, upsert: {}, find: {}, findOne: {}, all: {}},\n    after: { insert: {}, update: {}, remove: {}, find: {}, findOne: {}, all: {}},\n    all: { insert: {}, update: {}, remove: {}, find: {}, findOne: {}, all: {}}\n  },\n  directEnv: new Meteor.EnvironmentVariable(),\n  directOp: function directOp(func) {\n    return this.directEnv.withValue(true, func);\n  },\n  hookedOp: function hookedOp(func) {\n    return this.directEnv.withValue(false, func);\n  }\n};\n\nCollectionHooks.getUserId = function getUserId() {\n  var userId;\n\n  if (Meteor.isClient) {\n    Tracker.nonreactive(function () {\n      userId = Meteor.userId && Meteor.userId();\n    });\n  }\n\n  if (Meteor.isServer) {\n    try {\n      // Will throw an error unless within method call.\n      // Attempt to recover gracefully by catching:\n      userId = Meteor.userId && Meteor.userId();\n    } catch (e) {}\n\n    if (!userId) {\n      // Get the userId if we are in a publish function.\n      userId = publishUserId.get();\n    }\n  }\n\n  return userId;\n};\n\nCollectionHooks.extendCollectionInstance = function extendCollectionInstance(self, constructor) {\n  // Offer a public API to allow the user to define aspects\n  // Example: collection.before.insert(func);\n  _.each([\"before\", \"after\"], function (pointcut) {\n    _.each(advices, function (advice, method) {\n      if (advice === \"upsert\" && pointcut === \"after\") return;\n\n      Meteor._ensure(self, pointcut, method);\n      Meteor._ensure(self, \"_hookAspects\", method);\n\n      self._hookAspects[method][pointcut] = [];\n      self[pointcut][method] = function (aspect, options) {\n        var len = self._hookAspects[method][pointcut].push({\n          aspect: aspect,\n          options: CollectionHooks.initOptions(options, pointcut, method)\n        });\n\n        return {\n          replace: function (aspect, options) {\n            self._hookAspects[method][pointcut].splice(len - 1, 1, {\n              aspect: aspect,\n              options: CollectionHooks.initOptions(options, pointcut, method)\n            });\n          },\n          remove: function () {\n            self._hookAspects[method][pointcut].splice(len - 1, 1);\n          }\n        };\n      };\n    });\n  });\n\n  // Offer a publicly accessible object to allow the user to define\n  // collection-wide hook options.\n  // Example: collection.hookOptions.after.update = {fetchPrevious: false};\n  self.hookOptions = EJSON.clone(CollectionHooks.defaults);\n\n  // Wrap mutator methods, letting the defined advice do the work\n  _.each(advices, function (advice, method) {\n    var collection = Meteor.isClient || method === \"upsert\" ? self : self._collection;\n\n    // Store a reference to the original mutator method\n    var _super = collection[method];\n\n    Meteor._ensure(self, \"direct\", method);\n    self.direct[method] = function () {\n      var args = arguments;\n      return CollectionHooks.directOp(function () {\n        return constructor.prototype[method].apply(self, args);\n      });\n    };\n\n    collection[method] = function () {\n      if (CollectionHooks.directEnv.get() === true) {\n        return _super.apply(collection, arguments);\n      }\n\n      // NOTE: should we decide to force `update` with `{upsert:true}` to use\n      // the `upsert` hooks, this is what will accomplish it. It's important to\n      // realize that Meteor won't distinguish between an `update` and an\n      // `insert` though, so we'll end up with `after.update` getting called\n      // even on an `insert`. That's why we've chosen to disable this for now.\n      // if (method === \"update\" && _.isObject(arguments[2]) && arguments[2].upsert) {\n      //   method = \"upsert\";\n      //   advice = CollectionHooks.getAdvice(method);\n      // }\n\n      return advice.call(this,\n        CollectionHooks.getUserId(),\n        _super,\n        self,\n        method === \"upsert\" ? {\n          insert: self._hookAspects.insert || {},\n          update: self._hookAspects.update || {},\n          upsert: self._hookAspects.upsert || {}\n        } : self._hookAspects[method] || {},\n        function (doc) {\n          return  _.isFunction(self._transform)\n                  ? function (d) { return self._transform(d || doc); }\n                  : function (d) { return d || doc; };\n        },\n        _.toArray(arguments),\n        false\n      );\n    };\n  });\n};\n\nCollectionHooks.defineAdvice = function defineAdvice(method, advice) {\n  advices[method] = advice;\n};\n\nCollectionHooks.getAdvice = function getAdvice(method) {\n  return advices[method];\n};\n\nCollectionHooks.initOptions = function initOptions(options, pointcut, method) {\n  return CollectionHooks.extendOptions(CollectionHooks.defaults, options, pointcut, method);\n};\n\nCollectionHooks.extendOptions = function extendOptions(source, options, pointcut, method) {\n  options = _.extend(options || {}, source.all.all);\n  options = _.extend(options, source[pointcut].all);\n  options = _.extend(options, source.all[method]);\n  options = _.extend(options, source[pointcut][method]);\n  return options;\n};\n\nCollectionHooks.getDocs = function getDocs(collection, selector, options) {\n  var self = this;\n\n  var findOptions = {transform: null, reactive: false}; // added reactive: false\n\n  /*\n  // No \"fetch\" support at this time.\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n  */\n\n  // Bit of a magic condition here... only \"update\" passes options, so this is\n  // only relevant to when update calls getDocs:\n  if (options) {\n    // This was added because in our case, we are potentially iterating over\n    // multiple docs. If multi isn't enabled, force a limit (almost like\n    // findOne), as the default for update without multi enabled is to affect\n    // only the first matched document:\n    if (!options.multi) {\n      findOptions.limit = 1;\n    }\n  }\n\n  // Unlike validators, we iterate over multiple docs, so use\n  // find instead of findOne:\n  return collection.find(selector, findOptions);\n};\n\n// This function contains a snippet of code pulled and modified from:\n// ~/.meteor/packages/mongo-livedata/collection.js\n// It's contained in these utility functions to make updates easier for us in\n// case this code changes.\nCollectionHooks.getFields = function getFields(mutator) {\n  // compute modified fields\n  var fields = [];\n\n  _.each(mutator, function (params, op) {\n    //====ADDED START=======================\n    if (_.contains([\"$set\", \"$unset\", \"$inc\", \"$push\", \"$pull\", \"$pop\", \"$rename\", \"$pullAll\", \"$addToSet\", \"$bit\"], op)) {\n    //====ADDED END=========================\n      _.each(_.keys(params), function (field) {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        if (!_.contains(fields, field))\n          fields.push(field);\n      });\n    //====ADDED START=======================\n    } else {\n      fields.push(op);\n    }\n    //====ADDED END=========================\n  });\n\n  return fields;\n};\n\nCollectionHooks.reassignPrototype = function reassignPrototype(instance, constr) {\n  var hasSetPrototypeOf = typeof Object.setPrototypeOf === \"function\";\n\n  if (!constr) constr = typeof Mongo !== \"undefined\" ? Mongo.Collection : Meteor.Collection;\n\n  // __proto__ is not available in < IE11\n  // Note: Assigning a prototype dynamically has performance implications\n  if (hasSetPrototypeOf) {\n    Object.setPrototypeOf(instance, constr.prototype);\n  } else if (instance.__proto__) {\n    instance.__proto__ = constr.prototype;\n  }\n};\n\nCollectionHooks.wrapCollection = function wrapCollection(ns, as) {\n  if (!as._CollectionConstructor) as._CollectionConstructor = as.Collection;\n  if (!as._CollectionPrototype) as._CollectionPrototype = new as.Collection(null);\n\n  var constructor = as._CollectionConstructor;\n  var proto = as._CollectionPrototype;\n\n  ns.Collection = function () {\n    var ret = constructor.apply(this, arguments);\n    CollectionHooks.extendCollectionInstance(this, constructor);\n    return ret;\n  };\n\n  ns.Collection.prototype = proto;\n  ns.Collection.prototype.constructor = ns.Collection;\n\n  for (var prop in constructor) {\n    if (constructor.hasOwnProperty(prop)) {\n      ns.Collection[prop] = constructor[prop];\n    }\n  }\n};\n\nif (typeof Mongo !== \"undefined\") {\n  CollectionHooks.wrapCollection(Meteor, Mongo);\n  CollectionHooks.wrapCollection(Mongo, Mongo);\n} else {\n  CollectionHooks.wrapCollection(Meteor, Meteor);\n}\n\nif (Meteor.isServer) {\n  var _publish = Meteor.publish;\n  Meteor.publish = function (name, func) {\n    return _publish.call(this, name, function () {\n      // This function is called repeatedly in publications\n      var ctx = this, args = arguments;\n      return publishUserId.withValue(ctx && ctx.userId, function () {\n        return func.apply(ctx, args);\n      });\n    });\n  };\n\n  // Make the above available for packages with hooks that want to determine\n  // whether they are running inside a publish function or not.\n  CollectionHooks.isWithinPublish = function isWithinPublish() {\n    return publishUserId.get() !== undefined;\n  };\n}\n","CollectionHooks.defineAdvice(\"insert\", function (userId, _super, instance, aspects, getTransform, args, suppressAspects) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var callback = _.last(args);\n  var async = _.isFunction(callback);\n  var abort, ret;\n\n  // args[0] : doc\n  // args[1] : callback\n\n  // before\n  if (!suppressAspects) {\n    try {\n      _.each(aspects.before, function (o) {\n        var r = o.aspect.call(_.extend({transform: getTransform(args[0])}, ctx), userId, args[0]);\n        if (r === false) abort = true;\n      });\n\n      if (abort) return false;\n    } catch (e) {\n      if (async) return callback.call(self, e);\n      throw e;\n    }\n  }\n\n  function after(id, err) {\n    var doc = args[0];\n    if (id) {\n      doc = EJSON.clone(args[0]);\n      doc._id = id;\n    }\n    if (!suppressAspects) {\n      var lctx = _.extend({transform: getTransform(doc), _id: id, err: err}, ctx);\n      _.each(aspects.after, function (o) {\n        o.aspect.call(lctx, userId, doc);\n      });\n    }\n    return id;\n  }\n\n  if (async) {\n    args[args.length - 1] = function (err, obj) {\n      after(obj && obj[0] && obj[0]._id || obj, err);\n      return callback.apply(this, arguments);\n    };\n    return _super.apply(self, args);\n  } else {\n    ret = _super.apply(self, args);\n    return after(ret && ret[0] && ret[0]._id || ret);\n  }\n});","CollectionHooks.defineAdvice(\"update\", function (userId, _super, instance, aspects, getTransform, args, suppressAspects) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var callback = _.last(args);\n  var async = _.isFunction(callback);\n  var docs, docIds, fields, abort, prev = {};\n  var collection = _.has(self, \"_collection\") ? self._collection : self;\n\n  // args[0] : selector\n  // args[1] : mutator\n  // args[2] : options (optional)\n  // args[3] : callback\n\n  if (_.isFunction(args[2])) {\n    callback = args[2];\n    args[2] = {};\n  }\n\n  if (!suppressAspects) {\n    try {\n      if (aspects.before || aspects.after) {\n        fields = CollectionHooks.getFields(args[1]);\n        docs = CollectionHooks.getDocs.call(self, collection, args[0], args[2]).fetch();\n        docIds = _.map(docs, function (doc) { return doc._id; });\n      }\n\n      // copy originals for convenience for the \"after\" pointcut\n      if (aspects.after) {\n        prev.mutator = EJSON.clone(args[1]);\n        prev.options = EJSON.clone(args[2]);\n        if (_.some(aspects.after, function (o) { return o.options.fetchPrevious !== false; }) &&\n            CollectionHooks.extendOptions(instance.hookOptions, {}, \"after\", \"update\").fetchPrevious !== false) {\n          prev.docs = {};\n          _.each(docs, function (doc) {\n            prev.docs[doc._id] = EJSON.clone(doc);\n          });\n        }\n      }\n\n      // before\n      _.each(aspects.before, function (o) {\n        _.each(docs, function (doc) {\n          var r = o.aspect.call(_.extend({transform: getTransform(doc)}, ctx), userId, doc, fields, args[1], args[2]);\n          if (r === false) abort = true;\n        });\n      });\n\n      if (abort) return false;\n    } catch (e) {\n      if (async) return callback.call(self, e);\n      throw e;\n    }\n  }\n\n  function after(affected, err) {\n    if (!suppressAspects) {\n      var fields = CollectionHooks.getFields(args[1]);\n      var docs = CollectionHooks.getDocs.call(self, collection, {_id: {$in: docIds}}, args[2]).fetch();\n\n      _.each(aspects.after, function (o) {\n        _.each(docs, function (doc) {\n          o.aspect.call(_.extend({\n            transform: getTransform(doc),\n            previous: prev.docs && prev.docs[doc._id],\n            affected: affected,\n            err: err\n          }, ctx), userId, doc, fields, prev.mutator, prev.options);\n        });\n      });\n    }\n  }\n\n  if (async) {\n    args[args.length - 1] = function (err, affected) {\n      after(affected, err);\n      return callback.apply(this, arguments);\n    };\n    return _super.apply(this, args);\n  } else {\n    var affected = _super.apply(self, args);\n    after(affected);\n    return affected;\n  }\n});","CollectionHooks.defineAdvice(\"remove\", function (userId, _super, instance, aspects, getTransform, args, suppressAspects) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var callback = _.last(args);\n  var async = _.isFunction(callback);\n  var docs, abort, prev = [];\n  var collection = _.has(self, \"_collection\") ? self._collection : self;\n\n  // args[0] : selector\n  // args[1] : callback\n\n  if (!suppressAspects) {\n    try {\n      if (aspects.before || aspects.after) {\n        docs = CollectionHooks.getDocs.call(self, collection, args[0]).fetch();\n      }\n\n      // copy originals for convenience for the \"after\" pointcut\n      if (aspects.after) {\n        _.each(docs, function (doc) {\n          prev.push(EJSON.clone(doc));\n        });\n      }\n\n      // before\n      _.each(aspects.before, function (o) {\n        _.each(docs, function (doc) {\n          var r = o.aspect.call(_.extend({transform: getTransform(doc)}, ctx), userId, doc);\n          if (r === false) abort = true;\n        });\n      });\n\n      if (abort) return false;\n    } catch (e) {\n      if (async) return callback.call(self, e);\n      throw e;\n    }\n  }\n\n  function after(err) {\n    if (!suppressAspects) {\n      _.each(aspects.after, function (o) {\n        _.each(prev, function (doc) {\n          o.aspect.call(_.extend({transform: getTransform(doc), err: err}, ctx), userId, doc);\n        });\n      });\n    }\n  }\n\n  if (async) {\n    args[args.length - 1] = function (err) {\n      after(err);\n      return callback.apply(this, arguments);\n    };\n    return _super.apply(self, args);\n  } else {\n    var result = _super.apply(self, args);\n    after();\n    return result;\n  }\n});","CollectionHooks.defineAdvice(\"upsert\", function (userId, _super, instance, aspectGroup, getTransform, args, suppressAspects) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var callback = _.last(args);\n  var async = _.isFunction(callback);\n  var docs, docIds, fields, abort, prev = {};\n  var collection = _.has(self, \"_collection\") ? self._collection : self;\n\n  // args[0] : selector\n  // args[1] : mutator\n  // args[2] : options (optional)\n  // args[3] : callback\n\n  if (_.isFunction(args[2])) {\n    callback = args[2];\n    args[2] = {};\n  }\n\n  if (!suppressAspects) {\n    if (aspectGroup.upsert.before) {\n      fields = CollectionHooks.getFields(args[1]);\n      docs = CollectionHooks.getDocs.call(self, collection, args[0], args[2]).fetch();\n      docIds = _.map(docs, function (doc) { return doc._id; });\n    }\n\n    // copy originals for convenience for the \"after\" pointcut\n    if (aspectGroup.update.after) {\n      if (_.some(aspectGroup.update.after, function (o) { return o.options.fetchPrevious !== false; }) &&\n          CollectionHooks.extendOptions(instance.hookOptions, {}, \"after\", \"update\").fetchPrevious !== false) {\n        prev.mutator = EJSON.clone(args[1]);\n        prev.options = EJSON.clone(args[2]);\n        prev.docs = {};\n        _.each(docs, function (doc) {\n          prev.docs[doc._id] = EJSON.clone(doc);\n        });\n      }\n    }\n\n    // before\n    if (!suppressAspects) {\n      _.each(aspectGroup.upsert.before, function (o) {\n        var r = o.aspect.call(ctx, userId, args[0], args[1], args[2]);\n        if (r === false) abort = true;\n      });\n\n      if (abort) return false;\n    }\n  }\n\n  function afterUpdate(affected, err) {\n    if (!suppressAspects) {\n      var fields = CollectionHooks.getFields(args[1]);\n      var docs = CollectionHooks.getDocs.call(self, collection, {_id: {$in: docIds}}, args[2]).fetch();\n\n      _.each(aspectGroup.update.after, function (o) {\n        _.each(docs, function (doc) {\n          o.aspect.call(_.extend({\n            transform: getTransform(doc),\n            previous: prev.docs && prev.docs[doc._id],\n            affected: affected,\n            err: err\n          }, ctx), userId, doc, fields, prev.mutator, prev.options);\n        });\n      });\n    }\n  }\n\n  function afterInsert(id, err) {\n    var doc = LocalCollection._removeDollarOperators(args[1]);\n    if (id) {\n      doc = EJSON.clone(doc);\n      doc._id = id;\n    }\n    if (!suppressAspects) {\n      var lctx = _.extend({transform: getTransform(doc), _id: id, err: err}, ctx);\n      _.each(aspectGroup.insert.after, function (o) {\n        o.aspect.call(lctx, userId, doc);\n      });\n    }\n  }\n\n  if (async) {\n    args[args.length - 1] = function (err, ret) {\n      if (ret.insertedId) {\n        afterInsert(ret.insertedId, err);\n      } else {\n        afterUpdate(ret.numberAffected, err);\n      }\n\n      return CollectionHooks.hookedOp(function () {\n        return callback.call(this, err, ret);\n      });\n    };\n\n    return CollectionHooks.directOp(function () {\n      return _super.apply(self, args);\n    });\n  } else {\n    var ret = CollectionHooks.directOp(function () {\n      return _super.apply(self, args);\n    });\n\n    if (ret.insertedId) {\n      afterInsert(ret.insertedId);\n    } else {\n      afterUpdate(ret.numberAffected);\n    }\n\n    return ret;\n  }\n});","CollectionHooks.defineAdvice(\"find\", function (userId, _super, instance, aspects, getTransform, args, suppressAspects) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var ret, abort;\n\n  // args[0] : selector\n  // args[1] : options\n\n  // before\n  if (!suppressAspects) {\n    _.each(aspects.before, function (o) {\n      var r = o.aspect.call(ctx, userId, args[0], args[1]);\n      if (r === false) abort = true;\n    });\n\n    if (abort) return false;\n  }\n\n  function after(cursor) {\n    if (!suppressAspects) {\n      _.each(aspects.after, function (o) {\n        o.aspect.call(ctx, userId, args[0], args[1], cursor);\n      });\n    }\n  }\n\n  ret = _super.apply(self, args);\n  after(ret);\n\n  return ret;\n});","CollectionHooks.defineAdvice(\"findOne\", function (userId, _super, instance, aspects, getTransform, args, suppressAspects) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var ret, abort;\n\n  // args[0] : selector\n  // args[1] : options\n\n  // before\n  if (!suppressAspects) {\n    _.each(aspects.before, function (o) {\n      var r = o.aspect.call(ctx, userId, args[0], args[1]);\n      if (r === false) abort = true;\n    });\n\n    if (abort) return false;\n  }\n\n  function after(doc) {\n    if (!suppressAspects) {\n      _.each(aspects.after, function (o) {\n        o.aspect.call(ctx, userId, args[0], args[1], doc);\n      });\n    }\n  }\n\n  ret = _super.apply(self, args);\n  after(ret);\n\n  return ret;\n});","if (Meteor.users) {\n  // If Meteor.users has been instantiated, attempt to re-assign its prototype:\n  CollectionHooks.reassignPrototype(Meteor.users);\n\n  // Next, give it the hook aspects:\n  var Collection = typeof Mongo !== \"undefined\" && typeof Mongo.Collection !== \"undefined\" ? Mongo.Collection : Meteor.Collection;\n  CollectionHooks.extendCollectionInstance(Meteor.users, Collection);\n}"]}